from flask import Flask, request, jsonify, send_file, send_from_directory
from flask_cors import CORS
import yt_dlp
import os
import json
import re
import logging
from urllib.parse import urlparse, quote
from pathlib import Path
from datetime import datetime
import hashlib

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

app = Flask(__name__, static_folder='.')

# CORS configuration with more security
CORS(app, resources={
    r"/api/*": {
        "origins": ["http://localhost:*", "http://127.0.0.1:*"],
        "methods": ["GET", "POST"],
        "allow_headers": ["Content-Type"]
    }
})

# Configuration
MAX_FILESIZE = 500 * 1024 * 1024  # 500MB max file size
ALLOWED_DOMAINS = []  # Empty means all domains allowed
DOWNLOAD_DIR = os.path.join(os.getcwd(), 'downloads')

# Create downloads directory if it doesn't exist
if not os.path.exists(DOWNLOAD_DIR):
    os.makedirs(DOWNLOAD_DIR)
    logger.info(f"Created download directory: {DOWNLOAD_DIR}")

@app.route('/')
def home():
    """Serve the main frontend page"""
    try:
        return send_file('index.html')
    except Exception as e:
        logger.error(f"Error serving index.html: {e}")
        return jsonify({'error': 'Frontend not found'}), 404

@app.route('/<path:path>')
def serve_static(path):
    """Serve static files (CSS, JS, etc.)"""
    try:
        # Prevent directory traversal attacks
        safe_path = Path(path).resolve()
        base_path = Path('.').resolve()
        
        # Check if the resolved path is within the base directory
        if not str(safe_path).startswith(str(base_path)):
            return jsonify({'error': 'Access denied'}), 403
            
        # Only serve specific file types
        allowed_extensions = {'.html', '.css', '.js', '.png', '.jpg', '.jpeg', '.gif', '.svg', '.ico'}
        if safe_path.suffix.lower() not in allowed_extensions:
            return jsonify({'error': 'File type not allowed'}), 403
            
        return send_from_directory('.', path)
    except Exception as e:
        logger.error(f"Error serving static file {path}: {e}")
        return jsonify({'error': 'File not found'}), 404

@app.route('/api')
def api_info():
    """API status and information"""
    return jsonify({
        'status': 'running',
        'message': 'Video Downloader API is active',
        'endpoints': {
            '/api/analyze': 'POST - Analyze video URL',
            '/api/download': 'POST - Download video',
            '/api/formats': 'POST - Get available formats'
        }
    })

@app.route('/api/analyze', methods=['POST'])
def analyze_video():
    """Analyze video URL and return metadata"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'Invalid JSON data'}), 400
            
        url = data.get('url')
        
        if not url:
            return jsonify({'error': 'URL is required'}), 400
        
        # Validate and sanitize URL
        if not is_valid_url(url):
            return jsonify({'error': 'Invalid URL format'}), 400
        
        # Check URL length to prevent DoS
        if len(url) > 2048:
            return jsonify({'error': 'URL too long'}), 400
        
        logger.info(f"Analyzing URL: {url[:100]}...")
        
        # yt-dlp options for extracting info only with proper headers
        ydl_opts = {
            'quiet': True,
            'no_warnings': True,
            'extract_flat': False,
            'socket_timeout': 30,
            'user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'referer': 'https://www.google.com/',
            'nocheckcertificate': True,
        }
        
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=False)
            
            # Extract available formats
            formats = []
            if 'formats' in info:
                seen_qualities = set()
                for f in info['formats']:
                    if f.get('height'):
                        quality_label = f"{f.get('height')}p"
                        if quality_label not in seen_qualities:
                            filesize = f.get('filesize') or f.get('filesize_approx')
                            formats.append({
                                'quality': quality_label,
                                'height': f.get('height'),
                                'ext': f.get('ext', 'mp4'),
                                'filesize': filesize,
                                'format_id': f.get('format_id')
                            })
                            seen_qualities.add(quality_label)
            
            # Sort formats by quality (highest first)
            formats.sort(key=lambda x: x['height'], reverse=True)
            
            # Sanitize title to prevent XSS
            title = sanitize_text(info.get('title', 'Unknown Title'))
            description = sanitize_text(info.get('description', ''))[:200]
            if description and len(info.get('description', '')) > 200:
                description += '...'
            
            logger.info(f"Successfully analyzed: {title}")
            
            return jsonify({
                'success': True,
                'title': title,
                'thumbnail': info.get('thumbnail', ''),
                'duration': info.get('duration', 0),
                'uploader': sanitize_text(info.get('uploader', 'Unknown')),
                'view_count': info.get('view_count', 0),
                'formats': formats[:6],  # Return top 6 quality options
                'description': description
            })
            
    except yt_dlp.utils.DownloadError as e:
        logger.error(f"Download error: {e}")
        return jsonify({'error': f'Failed to analyze video: {str(e)}'}), 400
    except Exception as e:
        logger.error(f"Unexpected error in analyze_video: {e}")
        return jsonify({'error': 'Failed to analyze video. Please check the URL and try again.'}), 500

@app.route('/api/formats', methods=['POST'])
def get_formats():
    """Get all available formats for a video"""
    try:
        data = request.get_json()
        url = data.get('url')
        
        if not url:
            return jsonify({'error': 'URL is required'}), 400
        
        ydl_opts = {
            'quiet': True,
            'no_warnings': True,
        }
        
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=False)
            
            # Organize formats by quality
            video_formats = []
            audio_formats = []
            
            for f in info.get('formats', []):
                format_info = {
                    'format_id': f.get('format_id'),
                    'ext': f.get('ext'),
                    'quality': f.get('format_note', 'Unknown'),
                    'filesize': f.get('filesize'),
                    'tbr': f.get('tbr')
                }
                
                if f.get('vcodec') != 'none' and f.get('acodec') != 'none':
                    format_info['type'] = 'video+audio'
                    format_info['resolution'] = f"{f.get('height')}p" if f.get('height') else 'Unknown'
                    video_formats.append(format_info)
                elif f.get('vcodec') != 'none':
                    format_info['type'] = 'video'
                    format_info['resolution'] = f"{f.get('height')}p" if f.get('height') else 'Unknown'
                    video_formats.append(format_info)
                elif f.get('acodec') != 'none':
                    format_info['type'] = 'audio'
                    format_info['abr'] = f.get('abr')
                    audio_formats.append(format_info)
            
            return jsonify({
                'success': True,
                'video_formats': video_formats,
                'audio_formats': audio_formats
            })
            
    except Exception as e:
        return jsonify({
            'error': f'Failed to get formats: {str(e)}'
        }), 500

@app.route('/api/download', methods=['POST'])
def download_video():
    """Download video in specified quality"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'Invalid JSON data'}), 400
            
        url = data.get('url')
        quality = data.get('quality', '720p')
        
        if not url:
            return jsonify({'error': 'URL is required'}), 400
        
        # Validate URL
        if not is_valid_url(url):
            return jsonify({'error': 'Invalid URL format'}), 400
        
        if len(url) > 2048:
            return jsonify({'error': 'URL too long'}), 400
        
        # Sanitize quality parameter
        if not re.match(r'^\d+p$|^audio$', quality):
            quality = '720p'
        
        logger.info(f"Downloading URL: {url[:100]}... Quality: {quality}")
        
        # Generate safe filename
        safe_filename = f"download_{hashlib.md5(url.encode()).hexdigest()[:8]}"
        
        # Common yt-dlp options to bypass restrictions
        common_opts = {
            'quiet': False,
            'no_warnings': True,
            'socket_timeout': 30,
            'user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'referer': 'https://www.youtube.com/',
            'nocheckcertificate': True,
            'outtmpl': os.path.join(DOWNLOAD_DIR, f'{safe_filename}_%(title).100s.%(ext)s'),
            'restrictfilenames': True,  # Restrict filenames to ASCII characters
            'http_headers': {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-us,en;q=0.5',
                'Sec-Fetch-Mode': 'navigate',
            },
            'extractor_args': {
                'youtube': {
                    'player_client': ['android', 'web'],
                    'skip': ['dash', 'hls']
                }
            },
        }
        
        # Configure download options based on quality
        if quality == 'audio':
            ydl_opts = {
                **common_opts,
                'format': 'bestaudio/best',
                'postprocessors': [{
                    'key': 'FFmpegExtractAudio',
                    'preferredcodec': 'mp3',
                    'preferredquality': '192',
                }],
            }
        else:
            # Extract resolution number (e.g., '1080p' -> '1080')
            resolution = quality.replace('p', '') if quality else '720'
            
            # Use a simpler format selector that works better with restrictions
            ydl_opts = {
                **common_opts,
                'format': f'best[height<={resolution}]/bestvideo[height<={resolution}]+bestaudio/best',
                'merge_output_format': 'mp4',
            }
        
        # Download the video
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=True)
            filename = ydl.prepare_filename(info)
            
            # Handle audio conversion
            if quality == 'audio':
                filename = filename.rsplit('.', 1)[0] + '.mp3'
            
            # Check file size
            if os.path.exists(filename):
                filesize = os.path.getsize(filename)
                if filesize > MAX_FILESIZE:
                    os.remove(filename)
                    return jsonify({'error': 'File size exceeds maximum limit (500MB)'}), 413
            
            logger.info(f"Download completed: {os.path.basename(filename)}")
            
            return jsonify({
                'success': True,
                'message': 'Video downloaded successfully',
                'filename': os.path.basename(filename),
                'title': sanitize_text(info.get('title', 'Unknown')),
                'filesize': os.path.getsize(filename) if os.path.exists(filename) else 0
            })
            
    except yt_dlp.utils.DownloadError as e:
        error_msg = str(e)
        logger.error(f"Download error: {error_msg}")
        
        # Provide more helpful error messages
        if '403' in error_msg or 'Forbidden' in error_msg:
            error_msg = "Access denied. This video may be restricted, age-restricted, or require sign-in. Try a different video or quality."
        elif 'Private video' in error_msg:
            error_msg = "This is a private video and cannot be downloaded."
        elif 'Video unavailable' in error_msg:
            error_msg = "Video is unavailable or has been removed."
        elif 'sign in' in error_msg.lower():
            error_msg = "This video requires authentication. Try a public video instead."
            
        return jsonify({'error': f'Download failed: {error_msg}'}), 400
    except Exception as e:
        logger.error(f"Unexpected error in download_video: {e}")
        return jsonify({'error': 'Download failed. Please try again or use a different video.'}), 500

@app.route('/api/download-file/<filename>', methods=['GET'])
def download_file(filename):
    """Serve the downloaded file"""
    try:
        # Sanitize filename to prevent directory traversal
        safe_filename = os.path.basename(filename)
        file_path = os.path.join(DOWNLOAD_DIR, safe_filename)
        
        # Verify the file is in the downloads directory
        if not os.path.abspath(file_path).startswith(os.path.abspath(DOWNLOAD_DIR)):
            logger.warning(f"Directory traversal attempt: {filename}")
            return jsonify({'error': 'Invalid filename'}), 403
        
        if os.path.exists(file_path):
            logger.info(f"Serving file: {safe_filename}")
            return send_file(file_path, as_attachment=True, download_name=safe_filename)
        else:
            logger.warning(f"File not found: {safe_filename}")
            return jsonify({'error': 'File not found'}), 404
    except Exception as e:
        logger.error(f"Error serving file {filename}: {e}")
        return jsonify({'error': 'Failed to download file'}), 500

def is_valid_url(url):
    """Validate URL format and check for suspicious patterns"""
    try:
        result = urlparse(url)
        
        # Check basic URL structure
        if not all([result.scheme, result.netloc]):
            return False
        
        # Only allow http and https
        if result.scheme not in ['http', 'https']:
            return False
        
        # Block localhost and private IPs to prevent SSRF
        blocked_hosts = ['localhost', '127.0.0.1', '0.0.0.0', '::1']
        if result.netloc.split(':')[0] in blocked_hosts:
            logger.warning(f"Blocked localhost/private IP: {result.netloc}")
            return False
        
        # Check for private IP ranges (basic check)
        if result.netloc.startswith('192.168.') or result.netloc.startswith('10.') or result.netloc.startswith('172.'):
            logger.warning(f"Blocked private IP range: {result.netloc}")
            return False
        
        return True
    except Exception as e:
        logger.error(f"URL validation error: {e}")
        return False

def sanitize_text(text):
    """Sanitize text to prevent XSS and other injection attacks"""
    if not text:
        return ""
    
    # Remove potentially dangerous characters
    text = str(text)
    text = re.sub(r'[<>"\']', '', text)
    text = text.strip()
    
    return text[:500]  # Limit length

@app.errorhandler(404)
def not_found(error):
    """Handle 404 errors"""
    return jsonify({'error': 'Not found'}), 404

@app.errorhandler(500)
def internal_error(error):
    """Handle 500 errors"""
    logger.error(f"Internal server error: {error}")
    return jsonify({'error': 'Internal server error'}), 500

@app.errorhandler(413)
def request_entity_too_large(error):
    """Handle file too large errors"""
    return jsonify({'error': 'File too large'}), 413

if __name__ == '__main__':
    print("=" * 60)
    print("🚀 Video Downloader API Server Starting...")
    print("=" * 60)
    print(f"📁 Download directory: {DOWNLOAD_DIR}")
    print(f"🌐 Server running on: http://localhost:5000")
    print("=" * 60)
    print("\nAvailable endpoints:")
    print("  GET  /                 - API status")
    print("  POST /api/analyze      - Analyze video URL")
    print("  POST /api/formats      - Get available formats")
    print("  POST /api/download     - Download video")
    print("=" * 60)
    print("\nPress Ctrl+C to stop the server")
    print()
    
    app.run(debug=True, host='0.0.0.0', port=5000)
